% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

Идея обобщённого программирования (\textsl{generic programming})
состоит в том, чтобы увеличить гибкость языков программирования,
расширяя возможности для параметризации программ типами данных.
Термин \emph{обобщённое программирование} может иметь различное
значение в зависимости от контекста. Говоря об
объектно-ориентированных языках, под ним понимают чаще всего
параметрический полиморфизм в языках, основанных на системе типов
Хиндли---Милнера, либо библиотеки обобщённых алгоритмов и
структур данных, метапрограммирование и так далее. Тем не менее,
когда говорят о функциональном программировании, его определение
относится к структурному полиморфизму~\cite{Loh2004}. Это
означает, что функции определяются над структурой типов данных. В
данной работе речь будет идти об \emph{обобщённом
программировании типов данных} (\textsl{datatype generic
programming})~\cite{Gib2007}, то есть о возможности перевода типа
в некоторое специальное \emph{представление}
(\textsl{representation}) его внутренней структуры и написания
функций, параметризованных такими представлениями и способных
единообразно их обрабатывать.

В работе изучается подход к обобщённому программированию типов
данных на языке Haskell, описанный в статье~\cite{VriLoh2014} и
реализованный в библиотеке \textsf{generics-sop}~\cite{generics-sop}.
Исследуется возможность применения средств подхода в задаче
построения зипперов~---~структур данных, используемых для
эффективной, чисто функциональной навигации по древовидной
структуре.

Раздел~\ref{sec:generic-prog} включает предварительные сведения об
обобщённом программировании типов данных. В
разделе~\ref{sec:zippers} содержится описание структуры данных
<<Зиппер>>, а также задачи, решаемой при помощи этой структуры,
излагается идея дифференцирования типов данных и раскрывается его
связь с типом зиппера, приводится набор правил дифференцирования,
который является результатом статьи~\cite{McBr2001}, позволяющий
механизировать получение зиппера, и рассматривается более ранний
известный подход к реализации обобщённого зиппера,
представленный в статье~\cite{MuRec2009}. Этот подход использует
средства библиотеки обобщённого программирования
\textsf{multirec}~\cite{multirec}, недостаток которой заключается в
необходимости переводить данный тип в его обобщённое
представление вручную или используя расширение языка
\textsf{Template Haskell}~\cite{multirec-th}, которое является
тяжеловесным средством метапрограммирования. В работе показано,
что библиотека \textsf{generics-sop} позволяет генерировать такое
представление автоматически, используя встроенные возможности
компилятора \textsf{GHC}.

В разделе~\ref{sec:generics-sop} представлен обзор возможностей
библиотеки \textsf{generics-sop}: описываются идеи и особенности
нового подхода к обобщённому программированию, приводится
несколько примеров описания обобщённых функций с помощью
\textsf{generics-sop}.

В результате исследования получен механизм, позволяющий
автоматизировать процесс построения обобщённого представления
зиппера средствами данной библиотеки, он описывается в
разделе~\ref{sec:generic-zippers-sop}.

\section{Введение в обобщённое программирование на языке Haskell}
\label{sec:generic-prog}

Множество примеров применения обобщённого программирования
типов данных включает большое количество функций в языке Haskell,
которые могут быть определены систематическим образом для
широкого класса типов: функции проверки на равенство и сравнения,
различные виды преобразований между значениями типов и другими
форматами представления данных (JSON, XML и т.~д.), функции
обхода или навигации по структурам данных, а также доступа к
конкретным данным внутри структуры (линзы) и другие.

Чтобы раскрыть идею обобщённого программирования, рассмотрим
следующий пример. Предположим, что у нас есть тип данных
\texttts{A}, опишем функцию проверки на равенство для этого типа
(листинг~\ref{list:eq-a}).
\begin{figure}[h]
\begin{framed}
\ttfamily\small
eq$_\mb A$ :: A -> A -> \textbf{Bool}
\end{framed}
\caption{Функция проверки на равенство для типа \texttts{A}}
\label{list:eq-a}
\end{figure}

Определение функции \texttts{eq$_\mb{A}$} несложно дать, имея
определение типа \texttts{A}. Алгоритм неформально можно описать
так: если тип данных имеет несколько конструкторов, необходимо
проверить, что для двух аргументов выбран один и тот же
конструктор, и если это так, то сравнить поэлементно на равенство
аргументы конструктора.

Например, так определяется функция \texttts{eq$_\mb{Bool}$} для
элементарного типа данных \lstinline{Bool}, который имеет два
конструктора без аргументов (листинг~\ref{list:eq-bool}).
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{data} Bool = True | False\\
\\
eq$_\mb{Bool}$ :: \textbf{Bool} -> \textbf{Bool} -> \textbf{Bool}\\
eq$_\mb{Bool}$ True~ True~ = True\\
eq$_\mb{Bool}$ False False = True\\
eq$_\mb{Bool}$ \_~~~~ \_~~~~ = False
\end{framed}
\caption{Функция проверки на равенство для типа \lstinline{Bool}}
\label{list:eq-bool}
\end{figure}

Предположим теперь, что есть класс типов (листинг~\ref{list:generic}),
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
class Generic a where
  type Rep a
  from :: a -> Rep a
  to   :: Rep a -> a
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Класс типов, представимых в обобщённом виде}
\label{list:generic}
\end{figure}
который связывает тип \texttts{a}, любой экземпляр этого класса, c
изоморфным ему типом обобщённого представления \texttts{Rep a},
определяя преобразование между ними с помощью функций
\texttts{from} и \texttts{to}.

Теперь, если все типы \texttts{Rep a} имеют общую структуру, мы
можем ввести класс типов, определяющий функцию сравнения на
равенство \texttts{geq}, которая работает для всех типов
представления по индукции над их структурой, и определить с её
помощью функцию \texttts{eq} для любых типов, представимых в
обобщённом виде (листинг~\ref{list:geq}).

\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
class GEq repA where
  geq :: repA -> repA -> Bool

eq :: (Generic a, GEq (Rep a)) => a -> a -> Bool
eq x y = geq (from x) (from y)
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Определение обобщённой функции сравнения на равенство}
\label{list:geq}
\end{figure}

\subsection{Алгебраические типы данных}

Алгебраические типы данных
(АТД, \textsl{algebraic data types})~---~основной механизм,
использованный для реализации структур данных в функциональных
языках программирования. Они определяются как составные типы,
которые могут быть представлены в виде типов"/сумм из
типов"/произведений. Тип"/произведение соответствует декартову
произведению множеств значений типов, а тип"/сумма в теории
множеств совпадает с дизъюнктивным, или размеченным,
объединением, то есть множеством, элементами которого являются
пары, состоящие из метки (соответствующей конструктору) и
сопоставляемого с ней типа"/произведения (представляющего
аргументы конструктора).

Приведём наиболее простые примеры алгебраических типов данных.
Базовыми случаями являются единичный тип, то есть тип, состоящий
из одного конструктора без аргументов, нулевой тип~---~тип, не
имеющий конструкторов, и тип"/константа, единственный конструктор
которого принимает один аргумент. Примеры таких типов
представлены в листинге~\ref{list:base}. Слева от знака \texttts{=}
стоят конструкторы типов, а справа~---~конструкторы значений.
Примеры элементарных типа"/суммы и типа"/произведения приведены
в листингах~\ref{list:sum}--\ref{list:prod}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data Unit = Unit

data Zero

data Const a = Const a
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Базовые АТД: единичный тип, нулевой тип и тип"/константа}
\label{list:base}
\end{figure}
\begin{figure}[h]
\begin{framed}
{\ttfamily\small
\textbf{data} Either a b = Left a | Right b}
\end{framed}
\caption{Тип-сумма}
\label{list:sum}
\end{figure}
\begin{figure}[h]
\begin{framed}
{\ttfamily\small
\textbf{data} (,) a b = (,) a b}
\end{framed}
\caption{Тип-произведение}
\label{list:prod}
\end{figure}

Более сложным примером является рекурсивный тип бинарного дерева
\texttts{Tree}, определяемый c двумя конструкторами: \texttts{Leaf} для
листа и \texttts{Node} для узла, содержащего два корневых узла его
поддеревьев (листинг~\ref{list:bin-tree}). Тип \texttts{Tree}
представляет собой тип"/сумму единичного типа и типа"/произведения
двух типов"/констант.
\begin{figure}[h]
\begin{framed}
{\ttfamily\small
\textbf{data} Tree = Leaf | Node Tree Tree}
\end{framed}
\caption{Рекурсивный тип бинарного дерева}
\label{list:bin-tree}
\end{figure}

Вернёмся к примеру с определением обобщённой функции \texttts{eq}
(см.~листинг~\ref{list:geq}), рассмотренному в начале раздела. Мы
теперь можем, используя структуру алгебраических типов данных,
определить обобщённое представление для любого типа, являющегося
АТД. Определим, например, экземпляр класса \texttts{Generic}
(см.~листинг~\ref{list:generic}) для типа
\lstinline{Bool}~---~типа"/суммы двух единичных типов.

Для того, чтобы построить обобщённое представление,
соответствующее структуре типа \lstinline{Bool}, нам понадобится
ввести два типа"/комбинатора для суммы и единицы
(листинг~\ref{list:sum-unit}).
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data U         = Unit
data (a :+: b) = L a | R b
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Комбинаторы для единичного типа и типа"/суммы}
\label{list:sum-unit}
\end{figure}

Определение типа обобщённого представления \texttts{Rep
\textbf{Bool}} с функциями \texttts{from} и \texttts{to} через введённые
комбинаторы выглядит, как в листинге~\ref{list:generic-bool}.
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{instance} Generic \textbf{Bool} \textbf{where}\\
\ind\textbf{type} Rep \textbf{Bool} = U :+: U\\
\ind from True~~~~ = L Unit\\
\ind from False~~~ = R Unit\\
\ind to~~ (L Unit) = True\\
\ind to~~ (R Unit) = False
\end{framed}
\caption{Определение обобщённого представления для типа \lstinline{Bool}}
\label{list:generic-bool}
\end{figure}

Теперь можно определить экземпляры класса \texttts{GEq} из
листинга~\ref{list:geq} для типов"/комбинаторов
(листинг~\ref{list:geq-sum-unit}). В итоге функция \texttts{eq} будет
работать для типа \lstinline{Bool} и для любых алгебраических типов,
составленных из сумм и единиц и являющихся экземплярами класса
\texttts{Generic}.
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{instance} (GEq a, GEq b) => GEq (a :+: b) \textbf{where}\\
\ind geq (L x) (L y) = geq x y\\
\ind geq (R x) (R y) = geq x y\\
\ind geq \_~~~~ \_~~~~ = False\\
\textbf{instance} GEq U \textbf{where}\\
\ind geq Unit Unit = True
\end{framed}
\caption{Определение работы \texttts{geq} для типов-сумм и единичных типов}
\label{list:geq-sum-unit}
\end{figure}

\subsection{Функторы}

Под термином \emph{функтор} в данной работе мы будем понимать
отображение, определённое на типах. Заметим, что это соответствует
теоретико"/категорному понятию функтора как отображения между
категориями, если рассматривать типы как категории, где объектами
типа \texttts{A} являются все возможные значения данного типа, а
морфизмами функции типа \texttts{A~"/>~A}. Формальное
определение функтора в теории категорий также требует выполнения
двух уравнений~---~сохранения единичного морфизма и композиции.
Однако мы в рамках этой работы будем пользоваться нестрогим
определением функтора и не требуем соблюдения этих свойств.

С программистской точки зрения, функтор~---~это полиморфный тип,
то есть тип, параметризованный другим типом. В языке Haskell введён
дополнительный уровень абстракции над типами~---~виды, или сорта,
типов (\textsl{kinds})~\cite{Loh2015}. Вид \texttts{*} соответствует
всем типам, значениями которых являются термы. Полностью
применённая форма любого типа (если он параметризован),
определённого через ключевое слово \lstinline{data}, имеет вид
\texttts{*}. Если \texttts{k} и \texttts{l}~---~виды, то типы вида
\texttts{l}, параметризованные типами вида \texttts{k}, будут иметь вид
\texttts{k~"/>~l}.

Например, типы \lstinline{Int} и список \lstinline{[Int]}~---~вида
\texttts{*}, а тип \texttts{[]}~---~неприменённая форма
параметризованного типа списка, представленного в
листинге~\ref{list:list},~---~вида \texttts{*~"/>~*}.
\begin{figure}[h]
\begin{framed}
\lstinline{data [] a = [] | a : [a]}
\end{framed}
\caption{Полиморфный тип списка}
\label{list:list}
\end{figure}

Функторы имеют вид \texttts{*~"/>~*}. Тип списка является примером
функтора.

Для того, чтобы строить обобщённые представления любых
функторов, необходимо ввести новую систему комбинаторов, как в
листинге~\ref{list:combinators}. Типы \texttts{K a}, \texttts{U},
\texttts{f~:+:~g} и \texttts{f~:\tms:~g} соответствуют
типу"/константе, единичному типу и типам суммы и произведения
(см.~листинги~\ref{list:base}--\ref{list:prod}), все они теперь
дополнительно параметризованы типом \texttts{x} и имеют вид
\texttts{*~"/>~*}. Тип \texttts{I} позволяет обобщённо представить
параметр функтора.
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{data} K a~~~~~~ x = K a\\
\textbf{data} I~~~~~~~~ x = I x\\
\textbf{data} U~~~~~~~~ x = Unit\\
\textbf{data} (f :+: g) x = L (f x) | R (g x)\\
\textbf{data} (f :\tms: g) x = f x :\tms: g x
\end{framed}
\caption{Типы-комбинаторы для обобщённого представления функторов}
\label{list:combinators}
\end{figure}

С помощью новых комбинаторов можно представлять не только
функторы, но и вообще любые алгебраические типы данных. Такой
подход к построению обобщённого представления структуры типов
используется в~\cite{MuRec2009}.

Для определения обобщённого представления функторов требуется
также новый класс \texttts{Generic1} (листинг~\ref{list:generic1}), в
котором тип \texttts{Rep~f} будет вида \texttts{*~"/>~*}. В
листинге~\ref{list:generic-pair} приводится в качестве примера
представление функтора \lstinline{Pair Int}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
class Generic1 f where
  type Rep1 f :: * -> *
  from1 :: f p -> Rep1 f p
  to1   :: Rep1 f p -> f p
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Класс обобщённо представимых функторов}
\label{list:generic1}
\end{figure}
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{data} Pair a b = Pair a b\\
\\
\textbf{instance} Generic1 (Pair \textbf{Int}) \textbf{where}\\
\ind\textbf{type} Rep1 (Pair \textbf{Int}) = K Int :\tms: I\\
\ind ...
\end{framed}
\caption{Пример типа обобщённого представления функтора}
\label{list:generic-pair}
\end{figure}

Необходимость введения отдельного класса для представления
функторов видится существенным недостатком, однако при
рассмотренном подходе для этого не существует другой возможности.
Такой способ принят в старой технологии обобщённого
программирования \textsf{GHC generics}~\cite{ghc-generics},
реализованной в компиляторе \textsf{GHC}. В
разделе~\ref{sec:generics-sop} будет показано, что новый подход
избавлен от этого недостатка.

\section{Зипперы}
\label{sec:zippers}

\section{Обобщённое программирование с \textsf{generics-sop}}
\label{sec:generics-sop}

\section{Реализация обобщённого зиппера}
\label{sec:generic-zippers-sop}

% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\appendix
\ifthenelse{\value{worktype} > 1}{%
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  }%
}{
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  }%
}

\section{Пример работы программы}

Здесь длинный листинг с примером работы.

\end{document}
