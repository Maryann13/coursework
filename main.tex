% В этом файле следует писать текст работы, разбивая его на
% разделы (section), подразделы (subsection) и, если нужно,
% главы (chapter).

% Предварительно следует указать необходимую информацию
% в файле SETUP.tex

\input{preamble.tex}

\begin{document}

\Intro

Идея обобщённого программирования (\textsl{generic programming})
состоит в том, чтобы увеличить гибкость языков программирования,
расширяя возможности для параметризации программ типами данных.
Термин \emph{обобщённое программирование} может иметь различное
значение в зависимости от контекста. Говоря об
объектно"/ориентированных языках, под ним понимают чаще всего
параметрический полиморфизм в языках, основанных на системе типов
Хиндли---Милнера, либо библиотеки обобщённых алгоритмов и
структур данных, метапрограммирование и так далее. Тем не менее,
когда говорят о функциональном программировании, его определение
относится к структурному полиморфизму~\cite{Loh2004}. Это
означает, что функции определяются над структурой типов данных. В
данной работе речь будет идти об \emph{обобщённом
программировании типов данных} (\textsl{datatype generic
programming})~\cite{Gib2007}, то есть о возможности перевода типа
в некоторое специальное \emph{представление}
(\textsl{representation}) его внутренней структуры и написания
функций, параметризованных такими представлениями и способных
единообразно их обрабатывать.

В работе изучается подход к обобщённому программированию типов
данных на языке Haskell, описанный в статье~\cite{VriLoh2014} и
реализованный в библиотеке \textsf{generics-sop}~\cite{generics-sop}.
Исследуется возможность применения средств подхода в задаче
построения зипперов~--- структур данных, используемых для
эффективной, чисто функциональной навигации по древовидной
структуре.

Раздел~\ref{sec:generic-prog} включает предварительные сведения об
обобщённом программировании типов данных. В
разделе~\ref{sec:zippers} содержится описание структуры данных
<<Зиппер>>, а также задачи, решаемой при помощи этой структуры,
излагается идея дифференцирования типов данных и раскрывается его
связь с типом зиппера, приводится набор правил дифференцирования,
который является результатом статьи~\cite{McBr2001}, позволяющий
механизировать получение зиппера, и рассматривается более ранний
известный подход к реализации обобщённого зиппера,
представленный в статье~\cite{MuRec2009}. Этот подход использует
средства библиотеки обобщённого программирования
\textsf{multirec}~\cite{multirec}, недостаток которой заключается в
необходимости переводить данный тип в его обобщённое
представление вручную или используя расширение языка
\textsf{Template Haskell}~\cite{multirec-th}, которое является
тяжеловесным средством метапрограммирования. В работе показано,
что библиотека \textsf{generics-sop} позволяет генерировать такое
представление автоматически, используя встроенные возможности
компилятора \textsf{GHC}.

В разделе~\ref{sec:generics-sop} представлен обзор возможностей
библиотеки \textsf{generics-sop}: описываются идеи и особенности
нового подхода к обобщённому программированию, обсуждаются преимущества предлагаемой формы структурного представления типов и техники перевода старого представления в новое.

В результате исследования получен механизм, позволяющий
автоматизировать процесс построения обобщённого представления
зиппера средствами данной библиотеки, он описывается в
разделе~\ref{sec:generic-zippers-sop}.

\section{Введение в обобщённое программирование на языке Haskell}
\label{sec:generic-prog}

Множество примеров применения обобщённого программирования
типов данных включает большое количество функций в языке Haskell,
которые могут быть определены систематическим образом для
широкого класса типов: функции проверки на равенство и сравнения,
различные виды преобразований между значениями типов и другими
форматами представления данных (JSON, XML и т.~д.), функции
обхода или навигации по структурам данных, а также доступа к
конкретным данным внутри структуры (линзы) и другие.

Чтобы раскрыть идею обобщённого программирования, рассмотрим
следующий пример. Предположим, что у нас есть тип данных
\texttts{A}, опишем функцию проверки на равенство для этого типа
(листинг~\ref{list:eq-a}).
\begin{figure}[h]
\begin{framed}
\ttfamily\small
eq$_\mb A$ :: A -> A -> \textbf{Bool}
\end{framed}
\caption{Функция проверки на равенство для типа \texttts{A}}
\label{list:eq-a}
\end{figure}

Определение функции \texttts{eq$_\mb{A}$} несложно дать, имея
определение типа \texttts{A}. Алгоритм неформально можно описать
так: если тип данных имеет несколько конструкторов, необходимо
проверить, что для двух аргументов выбран один и тот же
конструктор, и если это так, то сравнить поэлементно на равенство
аргументы конструктора.

Например, так определяется функция \texttts{eq$_\mb{Bool}$} для
элементарного типа данных \lstinline{Bool}, который имеет два
конструктора без аргументов (листинг~\ref{list:eq-bool}).
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{data} Bool = True | False\\
\\
eq$_\mb{Bool}$ :: \textbf{Bool} -> \textbf{Bool} -> \textbf{Bool}\\
eq$_\mb{Bool}$ True~ True~ = True\\
eq$_\mb{Bool}$ False False = True\\
eq$_\mb{Bool}$ \_~~~~ \_~~~~ = False
\end{framed}
\caption{Функция проверки на равенство для типа \lstinline{Bool}}
\label{list:eq-bool}
\end{figure}

Предположим теперь, что есть класс типов (листинг~\ref{list:generic}),
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
class Generic a where
  type Rep a
  from :: a -> Rep a
  to   :: Rep a -> a
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Класс типов, представимых в обобщённом виде}
\label{list:generic}
\end{figure}
который связывает тип \texttts{a}, любой экземпляр этого класса, c
изоморфным ему типом обобщённого представления \texttts{Rep a},
определяя преобразование между ними с помощью функций
\texttts{from} и \texttts{to}.

Теперь, если все типы \texttts{Rep a} имеют общую структуру, мы
можем ввести класс типов, определяющий функцию сравнения на
равенство \texttts{geq}, которая работает для всех типов
представления по индукции над их структурой, и определить с её
помощью функцию \texttts{eq} для любых типов, представимых в
обобщённом виде (листинг~\ref{list:geq}).

\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
class GEq repA where
  geq :: repA -> repA -> Bool

eq :: (Generic a, GEq (Rep a)) => a -> a -> Bool
eq x y = geq (from x) (from y)
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Определение обобщённой функции сравнения на равенство}
\label{list:geq}
\end{figure}

\subsection{Алгебраические типы данных}

Алгебраические типы данных
(АТД, \textsl{algebraic data types})~--- основной механизм,
использованный для реализации структур данных в функциональных
языках программирования. Они определяются как составные типы,
которые могут быть представлены в виде типов"/сумм из
типов"/произведений. Тип"/произведение соответствует декартову
произведению множеств значений типов, а тип"/сумма в теории
множеств совпадает с дизъюнктным, или размеченным,
объединением, то есть множеством, элементами которого являются
пары, состоящие из метки (соответствующей конструктору) и
сопоставляемого с ней типа"/произведения (представляющего
аргументы конструктора).

Приведём наиболее простые примеры алгебраических типов данных.
Базовыми случаями являются единичный тип, то есть тип, состоящий
из одного конструктора без аргументов, нулевой тип~--- тип, не
имеющий конструкторов, и тип"/константа, единственный конструктор
которого принимает один аргумент. Примеры таких типов
представлены в листинге~\ref{list:base}. Слева от знака \texttts{=}
стоят конструкторы типов, а справа~--- конструкторы значений.
Примеры элементарных типа"/суммы и типа"/произведения приведены
в листингах~\ref{list:sum}--\ref{list:prod}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data Unit = Unit

data Zero

data Const a = Const a
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Базовые АТД: единичный тип, нулевой тип и тип"/константа}
\label{list:base}
\end{figure}
\begin{figure}[h]
\begin{framed}
{\ttfamily\small
\textbf{data} Either a b = Left a | Right b}
\end{framed}
\caption{Тип-сумма}
\label{list:sum}
\end{figure}
\begin{figure}[h]
\begin{framed}
{\ttfamily\small
\textbf{data} (,) a b = (,) a b}
\end{framed}
\caption{Тип-произведение}
\label{list:prod}
\end{figure}

Более сложным примером является рекурсивный тип бинарного дерева
\texttts{Tree}, определяемый c двумя конструкторами: \texttts{Leaf} для
листа и \texttts{Node} для узла, содержащего два корневых узла его
поддеревьев (листинг~\ref{list:bin-tree}). Тип \texttts{Tree}
представляет собой тип"/сумму единичного типа и типа"/произведения
двух типов"/констант.
\begin{figure}[h]
\begin{framed}
{\ttfamily\small
\textbf{data} Tree = Leaf | Node Tree Tree}
\end{framed}
\caption{Рекурсивный тип бинарного дерева}
\label{list:bin-tree}
\end{figure}

Вернёмся к примеру с определением обобщённой функции \texttts{eq}
(см.~листинг~\ref{list:geq}), рассмотренному в начале раздела. Мы
теперь можем, используя структуру алгебраических типов данных,
определить обобщённое представление для любого типа, являющегося
АТД. Определим, например, экземпляр класса \texttts{Generic}
(см.~листинг~\ref{list:generic}) для типа
\lstinline{Bool}~--- типа"/суммы двух единичных типов.

Для того, чтобы построить обобщённое представление,
соответствующее структуре типа \lstinline{Bool}, нам понадобится
ввести два типа"/комбинатора для суммы и единицы
(листинг~\ref{list:sum-unit}).
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data U         = Unit
data (a :+: b) = L a | R b
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Комбинаторы для единичного типа и типа"/суммы}
\label{list:sum-unit}
\end{figure}

Определение типа обобщённого представления \texttts{Rep
\textbf{Bool}} с функциями \texttts{from} и \texttts{to} через введённые
комбинаторы выглядит, как в листинге~\ref{list:generic-bool}.
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{instance} Generic \textbf{Bool} \textbf{where}\\
\ind\textbf{type} Rep \textbf{Bool} = U :+: U\\
\ind from True~~~~ = L Unit\\
\ind from False~~~ = R Unit\\
\ind to~~ (L Unit) = True\\
\ind to~~ (R Unit) = False
\end{framed}
\caption{Определение обобщённого представления для типа \lstinline{Bool}}
\label{list:generic-bool}
\end{figure}

Теперь можно определить экземпляры класса \texttts{GEq} из
листинга~\ref{list:geq} для типов"/комбинаторов
(листинг~\ref{list:geq-sum-unit}). В итоге функция \texttts{eq} будет
работать для типа \lstinline{Bool} и для любых алгебраических типов,
составленных из сумм и единиц и являющихся экземплярами класса
\texttts{Generic}.
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{instance} (GEq a, GEq b) => GEq (a :+: b) \textbf{where}\\
\ind geq (L x) (L y) = geq x y\\
\ind geq (R x) (R y) = geq x y\\
\ind geq \_~~~~ \_~~~~ = False\\
\textbf{instance} GEq U \textbf{where}\\
\ind geq Unit Unit = True
\end{framed}
\caption{Определение работы \texttts{geq} для типов-сумм и единичных типов}
\label{list:geq-sum-unit}
\end{figure}

\subsection{Функторы}

Под термином \emph{функтор} в данной работе мы будем понимать
отображение, определённое на типах. Заметим, что это соответствует
теоретико"/категорному понятию функтора как отображения между
категориями~--- областью и кообластью в данном случае будет категория \textbf{Hask} типов языка Haskell, таким образом функтор, действуя на типы, переводит их в другие типы~--- объекты этой категории. Формальное
определение функтора в теории категорий также требует выполнения
двух уравнений, называемых в Haskell <<законами функтора>>,~--- сохранения единичного морфизма и композиции.
Однако мы в рамках этой работы будем пользоваться нестрогим
определением функтора и не требуем соблюдения этих свойств.

С программистской точки зрения, функтор~--- это полиморфный тип,
то есть тип, параметризованный другим типом. В языке Haskell введён
дополнительный уровень абстракции над типами~--- виды, или сорта,
типов (\textsl{kinds})~\cite{Loh2015}. Вид \texttts{*} соответствует
всем типам, значениями которых являются термы. Полностью
применённая форма любого типа (если он параметризован),
определённого через ключевое слово \lstinline{data}, имеет вид
\texttts{*}. Если \texttts{k} и \texttts{l}~--- виды, то типы вида
\texttts{l}, параметризованные типами вида \texttts{k}, будут иметь вид
\texttts{k~"/>~l}.

Например, типы \lstinline{Int} и список \lstinline{[Int]}~--- вида
\texttts{*}, а тип \texttts{[]}~--- неприменённая форма
параметризованного типа списка, представленного в
листинге~\ref{list:list},~--- вида \texttts{*~"/>~*}.
\begin{figure}[h]
\begin{framed}
\lstinline{data [] a = [] | a : [a]}
\end{framed}
\caption{Полиморфный тип списка}
\label{list:list}
\end{figure}

Функторы имеют вид \texttts{*~"/>~*}. Тип списка является примером
функтора.

Для того, чтобы строить обобщённые представления любых
функторов, необходимо ввести новую систему комбинаторов, как в
листинге~\ref{list:combinators}. Типы \texttts{K a}, \texttts{U},
\texttts{f~:+:~g} и \texttts{f~:\tms:~g} соответствуют
типу"/константе, единичному типу и типам суммы и произведения
(см.~листинги~\ref{list:base}--\ref{list:prod}), все они теперь
дополнительно параметризованы типом \texttts{x} и имеют вид
\texttts{*~"/>~*}. Тип \texttts{I} позволяет обобщённо представить
параметр функтора.
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{data} K a~~~~~~ x = K a\\
\textbf{data} I~~~~~~~~ x = I x\\
\textbf{data} U~~~~~~~~ x = Unit\\
\textbf{data} (f :+: g) x = L (f x) | R (g x)\\
\textbf{data} (f :\tms: g) x = f x :\tms: g x
\end{framed}
\caption{Типы-комбинаторы для обобщённого представления функторов}
\label{list:combinators}
\end{figure}

С помощью новых комбинаторов можно представлять не только
функторы, но и вообще любые алгебраические типы данных. Такой
подход к построению обобщённого представления структуры типов
используется в~\cite{MuRec2009}.

Для определения обобщённого представления функторов требуется
также новый класс \texttts{Generic1} (листинг~\ref{list:generic1}), в
котором тип \texttts{Rep1~f} будет вида \texttts{*~"/>~*}. В
листинге~\ref{list:generic-pair} приводится в качестве примера
представление функтора \lstinline{Pair Int}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
class Generic1 f where
  type Rep1 f :: * -> *
  from1 :: f p -> Rep1 f p
  to1   :: Rep1 f p -> f p
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Класс обобщённо представимых функторов}
\label{list:generic1}
\end{figure}
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{data} Pair a b = Pair a b\\
\\
\textbf{instance} Generic1 (Pair \textbf{Int}) \textbf{where}\\
\ind\textbf{type} Rep1 (Pair \textbf{Int}) = K \textbf{Int} :\tms: I\\
\ind ...
\end{framed}
\caption{Пример типа обобщённого представления функтора}
\label{list:generic-pair}
\end{figure}

Необходимость введения отдельного класса для представления
функторов видится существенным недостатком, однако при
рассмотренном подходе для этого не существует другой возможности.
Такой способ принят в старой технологии обобщённого
программирования \textsf{GHC generics}~\cite{ghc-generics},
реализованной в компиляторе \textsf{GHC}.

\section{Зипперы}
\label{sec:zippers}

Многие эффективные алгоритмы, применяемые в императивном программировании, используют деструктивные операции над элементами структур данных. Однако в случае неизменяемой структуры сложность таких алгоритмов становится $\Theta\,(\log n)$ или $\Theta\,(n)$ при наивном решении, когда копируется всё дерево.

Структура данных \emph{Зиппер}~--- эффективное решение задачи чисто функциональной навигации по древовидной структуре, предложенное Ж.~Юэ~\cite{Hue1997}. Задача формулируется как представление древовидной структуры данных вместе с фокусом на текущем узле, который может перемещаться влево, вправо, вниз и вверх по этой структуре.

Решение состоит в построении производной структуры, содержащей фокус, который указывает на текущий узел, и хранящей путь, восходящий от него к корню дерева. Элементы чисто функциональной структуры, представленной таким образом, можно изменять за константное время.

Зиппер является паттерном проектирования~\cite{Ad2010}, который можно использовать при реализации текстового редактора, где точкой фокуса будет текущее положение курсора, файловой системы (фокус~--- рабочий каталог), компилятора или интерактивного средства доказательства теорем. В качестве примера использования зиппера в промышленном ПО можно привести оконный менеджер \textsf{xmonad}~\cite{xmonad}.

\subsection{Тип зиппера}

Суть решения задачи навигации заключена в том, чтобы, выбирая направление для перемещения по дереву, на каждом уровне сохранять окружающий его \emph{контекст}, то есть все соседние для данного узлы. Тогда после каждого шага можно возвращаться вверх к корню, реализовав дополнительно функцию вставки (\textsl{plugging in}) узла в контекст. Путь к корню, таким образом, строится как список контекстов для каждого уровня дерева и выбранного направления.

Рассмотрим следующий пример типа терма в абстрактном синтаксическом дереве некоторого языка (листинг~\ref{list:term-type}).

\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data Term = Var String
          | Lambda String Term
          | App Term Term
          | If Term Term Term
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Тип терма}
\label{list:term-type}
\end{figure}

Предположим, что у нас имеется построенное дерево с узлами этого типа, как показано в листинге~\ref{list:term}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
term :: Term
term = If (Var "false")
          (App (Lambda "x" (Var "x"))
               (Var "38"))
          (Var "13")
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Пример дерева разбора терма}
\label{list:term}
\end{figure}
Значение \lstinline{term} является корнем этого дерева. Чтобы спуститься вниз от корня, сфокусировавшись, например, на подтерме со значением \lstinline{Var "x"}, для восстановления пути к корню требуется на первом шаге~--- опустившись до значения \texttts{App~(Lambda~\textquotedbl x\textquotedbl~(Var~\textquotedbl x\textquotedbl))~(Var~\textquotedbl 38\textquotedbl)}~--- сохранить окружающий контекст этого элемента, то есть левый и правый соседние узлы, затем сохранить, добавив в список, соседний узел подтерма \texttts{Lambda~\textquotedbl x\textquotedbl}~\lstinline{(Var "x")}~--- значение \lstinline{Var "13"}~--- и, наконец, на последнем шаге~--- константу \lstinline{"x"}, которая является контекстом для выбранного узла. 

Тип зиппера для терма и составляющий его тип контекста, соответствующие реализации изложенной идеи, приведены в листингах~\ref{list:term-zipper}--\ref{list:term-ctx}. Индексы конструкторов контекста указывают на выбранное направление, то есть порядковый номер дочернего узла, пройденного на текущем уровне в пути от корня к фокусу.

\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{type} TermZipper = (Term, [TermContext])
\end{framed}
\caption{Тип зиппера для терма}
\label{list:term-zipper}
\end{figure}

\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{data} TermContext = Lambda$_\m{1}$ String\\
\indN{~~~~~~~~~~~~~~~~~}| App$_\m{1}$ Term\\
\indN{~~~~~~~~~~~~~~~~~}| App$_\m{2}$ Term\\
\indN{~~~~~~~~~~~~~~~~~}| If$_\m{1}$ Term Term\\
\indN{~~~~~~~~~~~~~~~~~}| If$_\m{2}$ Term Term\\
\indN{~~~~~~~~~~~~~~~~~}| If$_\m{3}$ Term Term
\end{framed}
\caption{Тип контекста для терма}
\label{list:term-ctx}
\end{figure}

\subsection{Дифференцирование типов данных}

Получение типа контекста, как показывает К.~Макбрайд в статье~\cite{McBr2001},~--- чисто механический процесс, который можно выполнять, применяя к типу структуры данных, для которой требуется построить зиппер, набор математических преобразований, приведённый ниже. В записи данных формул $1$ и $0$ обозначают рассмотренные в разделе~\ref{sec:generic-prog} единичный и нулевой типы, а $S + T$ и $S \times T$ соответственно тип-сумму и тип-произведение (см.~листинги~\ref{list:base}--\ref{list:prod}).
\begin{flalign}
\partial_x x\quad &\mapsto\quad 1\\
\partial_x C\quad &\mapsto\quad 0\\
\partial_x (S + T)\quad &\mapsto\quad\partial_x S +\partial_x T\\
\partial_x (S \times T)\quad &\mapsto\quad S\times\partial_x T + \partial_x F\times G\\
\partial_x (S|_{y = T})\quad &\mapsto\quad\partial_x S|_{y = T} + \partial_y S|_{y = T}\times\partial_x T
\end{flalign}

Эти операции, которые можно использовать как список инструкций для автоматического построения типа контекста, похожи внешне на известные правила дифференцирования из математического анализа с тем отличием, что они определяются на типах. Для типа зиппера они сообщают нам, что
\begin{enumerate}[(1)]
  \item тип $x$ содержит один $x$ в тривиальном контексте,
  \item константы не содержат $x$,
  \item в $S + T$ можно найти $x$ либо в $S$, либо в $T$,
  \item в $S \times T$ можно найти $x$ в $S$, пропуская $T$, либо в $T$, пропуская $S$,
  \item подстановка выражения $T$ вместо переменной $y$ в формулу $S$.
\end{enumerate}

Предыдущий пример вывода типа контекста для терма с использованием приведённых правил записывается следующим образом.
\begin{flalign*}
\mathbf{term}\, &=\, C_{\mathbf{string}}+C_{\mathbf{string}}\times\mathbf{term}+\mathbf{term}^2+\mathbf{term}^3\\
\mathbf{term'}\, &=\, C_{\mathbf{string}}+2\times\mathbf{term}+3\times\mathbf{term}^2
\end{flalign*}

Применение этих правил можно запрограммировать на уровне типов. В данной работе была поставлена задача их использования с техникой обобщённого программирования для автоматизации получения типа контекста зиппера. Далее будет показан ранее имеющийся подход к этой проблеме, а найденное решение, основывающееся на новых средствах, приводится в разделе~\ref{sec:generic-zippers-sop}.

\subsection{Библиотека \textsf{multirec} и обобщённые зипперы}

В библиотеке \textsf{multirec} реализован подход к обобщённому программированию типов данных, описанный в~\cite{MuRec2009}. Проблема доступа к рекурсивным элементам структуры данных, включающая задачи свёртки и обхода по значениям типа, имеющего рекурсивную структуру, и в том числе навигации с помощью зиппера, решается для \emph{регулярных типов}\footnote{В статье выполняются построения для более сложного класса типов~--- \emph{взаимно рекурсивных}, однако в этой работе мы будем рассматривать только регулярные типы как их частный случай.}, подмножества алгебраических типов данных, которые имеют представление в виде наименьшей неподвижной точки некоторого полиномиального выражения над типами.

Тип \texttts{Term}, как показывает следующая запись, является регулярным типом.
\begin{flalign*}
\mathbf{term}\, &=\, C_{\mathbf{string}}+C_{\mathbf{string}}\times\mathbf{term}+\mathbf{term}^2+\mathbf{term}^3\\
&=\, \mu x.\,C_{\mathbf{string}}+C_{\mathbf{string}}\times x+x^2+x^3
\end{flalign*}

Выражения такого вида могут быть представлены как функторы, параметризованные типом \texttts{x}, и далее мы будем называть их \emph{полиномиальными функторами}.

В~\cite{MuRec2009} пользуются определением регулярного типа, чтобы ввести класс для обобщённого представления всех регулярных типов. Пусть для регулярного типа $a$ существует такой полиномиальный функтор $PF_a$, что
\[a\,\cong\,\mu y.\,PF_a.\]

Тогда, используя свойство наименьшей неподвижной точки $\mu y.\,F\,=\,F\,(\mu y.\,F)$, мы получаем изоморфизм типов
\[a\,\cong\,\mu y.\,PF_a\,\cong\,PF_a\,(\mu y.\,PF_a)\,\cong\,PF_a\,(a).\]

Класс регулярных типов, таким образом, определяется, как показано в листинге~\ref{list:reg}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
class Regular a where
  type PF a :: * -> *
  from      :: a -> PF a a
  to        :: PF a a -> a
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Класс регулярных типов}
\label{list:reg}
\end{figure}

Для обобщённого представления полиномиального функтора используются показанные в разделе~\ref{sec:generic-prog} типы"/комбинаторы \texttts{K a}, \texttts{U}, \texttts{I}, \texttts{f~:+:~g} и \texttts{f~:\tms:~g} (см.~листинг~\ref{list:combinators}).

Функции на уровне типов, вычисляющие тип контекста как производную заданного типа, в данном подходе описываются нижеприведённым образом (листинг~\ref{list:ctx}).
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{data family} Context (f :: * -> *) a\\
\\
\textbf{data instance} Context (K b)~~~~~a\\
\textbf{data instance} Context U~~~~~~~~~a\\
\textbf{data instance} Context I~~~~~~~~~a = CI\\
\textbf{data instance} Context (f :+: g) a = CL (Context f a)\\
\indN{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}| CR (Context g a)\\
\textbf{data instance} Context (f :\tms: g) a = C1 (Context f a) (g a)\\
\indN{~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}| C2 (f a) (Context g a)
\end{framed}
\caption{Вычисление типа контекста}
\label{list:ctx}
\end{figure}

В библиотеке также введён класс \texttts{Zipper}, предоставляющий ряд функций для навигации по структуре, а определение типа фокуса (\textsl{location}) выглядит, как в листинге~\ref{list:loc}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data Loc a where
  Loc :: (Regular a, Zipper (PF a) a)
         => a -> [Context (PF a) a] -> Loc a
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Тип фокуса}
\label{list:loc}
\end{figure}

Недостаток реализации \textsf{multirec} заключается в необходимости вручную переводить тип в регулярное представление или обращаясь к метапрограммному средству \textsf{Template Haskell}, предоставляющему на этапе компиляции возможности изменения синтаксического дерева программы. Представленный в следующем разделе подход~\cite{VriLoh2014} поддерживает более удобные и выразительные средства обобщённого программирования и позволяет генерировать код обобщённого представления типа автоматически.

\section{Обобщённое программирование с \textsf{generics-sop}}
\label{sec:generics-sop}

Реализация библиотеки \textsf{generics-sop} основывается на результатах исследования~\cite{VriLoh2014} и использует новые расширения языка Haskell, появившиеся в последние годы, что позволяет писать данными средствами более удобный и выразительный обобщённый код.

Данная библиотека предлагает новый стиль обобщённого представления типов данных в виде списочных структур, отличающийся от представления в большинстве используемых в данное время библиотек обобщённого программирования типов данных, подобного рассмотренному в предыдущих разделах,~--- как комбинации бинарных сумм и произведений с использованием множества частных структур~--- комбинаторов типов. В новом подходе каждый тип представляется как единая $N$"/арная сумма, где каждый компонент суммы~--- единое $N$"/арное произведение.

Важным преимуществом нового представления является отделение метаданных от основного структурного представления типа, что делает конструкцию обобщённой структуры менее громоздкой, не содержащей лишней информации и более удобной в использовании, позволяющей писать чистый выразительный код.

\subsection{\textsl{N}-арные суммы и произведения}

Результатом исследования~\cite{VriLoh2014} является использование таких современных расширений системы типов Haskell, как \textsf{DataKinds, ConstraintKinds, PolyKinds} и другие, для формирования и обработки списков типов, кодирующих конечные суммы и произведения.

Расширение \textsf{DataKinds}, впервые появившееся в статье~\cite{WeJo2012}, позволяет продвигать типы на более высокий уровень~--- видов типов, и таким образом даёт возможность определять новые виды, соответствующие типу данных. При этом конструкторы значений становятся конструкторами новых типов. Однако такие продвинутые (\textsl{promoted}) типы являются ненаселёнными, то есть не имеют конструкторов значений, и для того, чтобы строить термы с использованием этих типов, необходимо вводить структуры данных, предоставляющие для них конструкторы.

В листингах~\ref{list:np}--\ref{list:ns} приводятся определения типов $N$"/арного произведения и $N$"/арной суммы. Эти типы параметризованы типом полиморфного вида \lstinline{[k]} (полиморфизм на уровне видов типов включается расширением \textsf{PolyKinds}), который получен продвижением типа списка.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data NP (f :: k -> *) (xs :: [k]) where
  Nil  :: NP f '[]
  (:*) :: f x -> NP f xs -> NP f (x ': xs)
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Тип $N$-арного произведения}
\label{list:np}
\end{figure}

\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data NS (f :: k -> *) (xs :: [k]) where
  Z ::    f x  -> NS f (x ': xs)
  S :: NS f xs -> NS f (x ': xs)
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Тип $N$-арной суммы}
\label{list:ns}
\end{figure}

Конструкторы \texttts{S, Z, :*} и \texttts{Nil} создают значения этих типов, при добавлении элемента в сумму или произведение его тип заносится в список типов (здесь \texttts{'[]} и \texttts{':}~--- продвинутые версии конструкторов значений списка~--- для отличения их от обычных конструкторов списка в расширении \textsf{DataKinds} к ним добавляется знак \texttts{'}). Введённые структуры позволяют конструировать на уровне термов гетерогенные списки~--- списки, состоящие из значений разных типов.

В листинге~\ref{list:np-example} показан пример гетерогенного списка, построенного с помощью конструкторов типа \texttts{NP}. $N$"/арная сумма (листинг~\ref{list:ns-example})~--- это выбор из списка.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
hlist :: NP I '[String, Int, Char]
hlist = I "ab" :* I 3 :* I 'x' :* Nil
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Пример гетерогенного списка --- $N$-арного произведения}
\label{list:np-example}
\end{figure}

\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
type HChoice = NS I '[Char, Bool, Int, Bool]

c0, c2 :: HChoice
c0 = Z (I 'a')
c2 = S (S (Z (I 13)))
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{$N$-арная сумма --- выбор из списка}
\label{list:ns-example}
\end{figure}

\subsection{Класс \textsf{Generic} и автоматическая генерация обобщённого представления}

Используя типы \texttts{NS} и \texttts{NP}, можно выразить структуру алгебраического типа данных в виде $N$"/арной суммы произведений. К примеру, обобщённое представление типа \texttts{Term} из раздела~\ref{sec:zippers} (см.~листинг~\ref{list:term-type}) будет выглядеть, как в листинге~\ref{list:rep-term}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
type RepTerm = NS (NP I)
  '[ '[String]
   , '[String, Term]
   , '[Term, Term]
   , '[Term, Term, Term]
   ]
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Пример обобщённого представления типа}
\label{list:rep-term}
\end{figure}

$N$"/арные произведения (внутренние списки типов) представляют наборы аргументов конструкторов, а выбор из суммы соответствует выбору конкретного конструктора.

Класс \texttts{Generic} для всех типов, имеющих обобщённое представление такого вида, можно определить, как в листинге~\ref{list:generic-sop}, подобно тому, как было показано в разделе~\ref{sec:generic-prog}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
type Rep a = NS (NP I) (Code a)

class Generic (a :: *) where
  type Code a :: [[*]]  
  from :: a -> Rep a
  to   :: Rep a -> a
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Класс обобщённо представимых типов}
\label{list:generic-sop}
\end{figure}

Функции \texttts{from} и \texttts{to} задают изоморфизм типов \texttts{a} и \texttts{Rep a} при условии, что их композиция является тождественным отображением, а \texttts{Code a}~--- список списков типов, кодирующий представление в виде $N$"/арной суммы произведений. Такой код позволяет устанавливать соответствие между типом данных и его обобщённым представлением, тем не менее это всё ещё необходимо делать вручную.

Реализация класса \texttts{Generic} в библиотеке \textsf{generics-sop} более сложная~--- она автоматизирует процесс построения представления типа, используя собственный класс \texttts{Generic} компилятора \textsf{GHC} и переводя старое представление на основе комбинаторов в новое~--- в виде $N$"/арной суммы произведений. Код полного определения класса \texttts{Generic} из библиотеки \textsf{generics-sop} представлен в листинге~\ref{list:generics-sop-generic}.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
newtype SOP (f :: (k -> *)) (xss :: [[k]])
  = SOP (NS (NP f) xss)
  
type Rep a = SOP I (Code a)

class (All SListI (Code a)) => Generic (a :: *) where
  type Code a :: [[*]]
  type Code a = GCode a

  from         :: a -> Rep a
  default from :: (GFrom a, GHC.Generic a,
                  Rep a ~ SOP I (GCode a))
                  => a -> Rep a
  from = gfrom

  to         :: Rep a -> a
  default to :: (GTo a, GHC.Generic a,
                Rep a ~ SOP I (GCode a))
                => Rep a -> a
  to = gto
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Полное определение класса \texttts{Generic}}
\label{list:generics-sop-generic}
\end{figure}

Функции \texttts{gfrom} и \texttts{gto} определены в библиотеке \textsf{generics-sop}~--- они реализуют технику, известную как \textsl{generic generic programming}~\cite{GGP2014}. Это техника перевода одних форм обобщённого представления типов данных в другие, что обеспечивает максимальную гибкость при использовании различных средств обобщённого программирования, применение которых можно комбинировать в одной программе, и это также является одним из преимуществ нового подхода.

Ниже приводится пример определения типа данных (листинг~\ref{list:bin-tree}) и автоматически генерируемого для него кода обобщённого представления. Строка \lstinline{deriving GHC.Generic} средствами компилятора создаёт для типа экземпляр класса \texttts{GHC.Generic}, а строка \lstinline{instance Generic (BinTree a)} преобразуется в следующий код (листинг~\ref{list:generic-bin-tree}).
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data BinTree a = Leaf a | Node (BinTree a) (BinTree a)
  deriving GHC.Generic

instance Generic (BinTree a)
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Определение АТД бинарного дерева}
\label{list:bin-tree}
\end{figure}

\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
instance Generic (BinTree a) where
  type Code (BinTree a) = '[ '[a]
                           , '[BinTree a, BinTree a]
                           ]
                           
  from :: BinTree a -> Rep (BinTree a)
  from (Leaf x)   = SOP (Z (I x :* Nil))
  from (Node l r) = SOP (S (Z (I l :* I r :* Nil)))
  
  to :: Rep (BinTree a) -> BinTree a
  to (SOP (Z (I x :* Nil)))            = Leaf x
  to (SOP (S (Z (I l :* I r :* Nil)))) = Node l r
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Автоматически генерируемый код обобщённого представления}
\label{list:generic-bin-tree}
\end{figure}

\section{Реализация обобщённого зиппера}
\label{sec:generic-zippers-sop}

В текущем разделе будет описан разработанный механизм автоматизированной генерации обобщённого представления контекста зиппера, основанный на структурном представлении типа в виде $N$"/арной суммы произведений, с использованием правил дифференцирования типов данных, рассмотренных в разделе~\ref{sec:zippers}.

Данное решение демонстрирует выразительность современных средств языка Haskell и нового подхода к обобщённому программированию типов данных и программированию на уровне типов применительно к задаче построения обобщённого зиппера.

\subsection{Введение алгебраических операций над типами}
Для дальнейшей работы с представлениями типов в форме вложенных списочных структур мы введём следующие функции на уровне типов, которые являются алгебраическими операциями, если введённые конструкции на типах мыслить как суммы и произведения, фактически же они соответствуют продвинутым версиям функций работы со списками:
\begin{itemize}
\item \textsl{сложение $N$-арных сумм произведений}~--- это конкатенация списков из списков типов;
\item \textsl{умножение типа на $N$-арную сумму произведений}~--- добавление типа в начало каждого внутреннего списка суммы;
\item \textsl{умножение $N$-арного произведения на сумму произведений}~--- конкатенация списка типов с каждым внутренним списком суммы.
\end{itemize}

Все функции определяются рекурсивно на списках уровня типов, их реализация приведена в листингах~\ref{list:sums-adding}--\ref{list:prod-mult}.
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{type family} (.++) (xs :: [[*]]) (ys :: [[*]]) :: [[*]]\\
\\
\textbf{type instance} (x ': xs) .++ ys = x ': (xs .++ ys)\\
\textbf{type instance} '[]~~~~~~~.++ ys = ys
\vspace{-0.25cm}
\end{framed}
\caption{Сложение $N$-арных сумм произведений}
\label{list:sums-adding}
\end{figure}

\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{type family} (.*) (x :: *) (ys :: [[*]]) :: [[*]]\\
\\
\textbf{type instance} x .* (ys ': yss) = (x ': ys) ': (x .* yss)\\
\textbf{type instance} x .* '[]~~~~~~~~~= '[]
\end{framed}
\caption{Умножение типа на $N$-арную сумму произведений}
\label{list:type-mult}
\end{figure}
\newpage

\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{type family} (.**) (xs :: [*]) (ys :: [[*]]) :: [[*]]\\
\\
\textbf{type instance} (x ': xs) .** yss = x .* (xs .** yss)\\
\textbf{type instance} '[]~~~~~~~.** yss = yss
\end{framed}
\caption{Умножение $N$-арного произведения на сумму произведений}
\label{list:prod-mult}
\end{figure}

Например, вызов \lstinline{'[Int, Bool] .** '[ '[Bool], '[Bool, Char]]} вычислит тип \lstinline{'[ '[Int, Bool, Bool], '[Int, Bool, Bool, Char]]}.

Введение приоритета операций (листинг~\ref{list:priority}) позволит далее не ставить скобки в выражениях с их участием.
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
infixr 6 .++
infixr 7 .*
infixr 7 .**
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Введение приоритета операций}
\label{list:priority}
\end{figure}

\subsection{Получение типа контекста}

Следующим этапом для построения обобщённого представления типа контекста является определение функции дифференцирования $N$"/арного произведения типов (листинг~\ref{list:diff-prod}).
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{type family} DiffProd (a :: *) (xs :: [*]) :: [[*]] \textbf{where}\\
\ind DiffProd a '[]  = '[]\\
\ind DiffProd a '[a] = '[ '[]]\\
\ind DiffProd a '[x] = '[]\\
\ind DiffProd a (x ': xs)\\
\ind\ind = xs .** DiffProd a '[x] .++ x .* DiffProd a xs
\end{framed}
\caption{Дифференцирование $N$"/арного произведения}
\label{list:diff-prod}
\end{figure}

Функция, вычисляющая тип контекста, реализованная с использованием всех введённых ранее операций, представлена в листинге~\ref{list:to-context}.\newpage
\begin{figure}[h]
\begin{framed}
\ttfamily\small
\textbf{type family} ToContext (a :: *) (code :: [[*]]) :: [[*]]\\
\\
\textbf{type instance} ToContext a (xs ': xss)\\
\ind = DiffProd a xs .++ ToContext a xss\\
\textbf{type instance} ToContext a '[] = '[]
\end{framed}
\caption{Генерация типа контекста}
\label{list:to-context}
\end{figure}

К примеру, для типа \texttts{Tree} (листинг~\ref{list:tree}) и вызова
\begin{lstlisting}[language=Haskell]
type RepTreeContext = NS (NP I) (ToContext Tree (Code Tree))
\end{lstlisting}
будет автоматически сгенерирован следующий код (листинг~\ref{list:rep-context}).
\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
data Tree = Leaf  Int
          | TNode Tree Tree Int Bool Tree
          | BNode Bool Tree Tree
  deriving GHC.Generic

instance Generic Tree
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{АТД: дерево}
\label{list:tree}
\end{figure}

\begin{figure}[h]
\begin{framed}
\vspace{-0.25cm}
\begin{lstlisting}
type RepTreeContext = NS (NP I)
  ('[ '[Tree, Int, Bool, Tree]
    , '[Tree, Int, Bool, Tree]
    , '[Tree, Tree, Int, Bool]
    , '[Bool, Tree]
    , '[Bool, Tree] ])
\end{lstlisting}
\vspace{-0.25cm}
\end{framed}
\caption{Автоматически генерируемый код типа контекста}
\label{list:rep-context}
\end{figure}

\Conc

Результатом данной работы является полученная техника построения типа контекста обобщённого зиппера, которая служит примером возможности применения средств обобщённого программирования к различным задачам эффективного обхода структур данных, их обработки и так далее. Выразительность приведённого кода демонстрирует преимущества применения нового подхода к обобщённому программированию типов данных к поставленной задаче.

В ходе исследования были изучены имеющиеся подходы к обобщённому программированию типов данных, проведён их сравнительный анализ, выявлены достоинства и недостатки различных библиотек обобщённого программирования.

% Печать списка литературы (библиографии)
\printbibliography[heading=bibintoc%
    %,title=Библиография % если хочется это слово
]
% Файл со списком литературы: biblio.bib
% Подробно по оформлению библиографии:
% см. документацию к пакету biblatex-gost
% http://ctan.mirrorcatalogs.com/macros/latex/exptl/biblatex-contrib/biblatex-gost/doc/biblatex-gost.pdf
% и огромное количество примеров там же:
% http://mirror.macomnet.net/pub/CTAN/macros/latex/contrib/biblatex-contrib/biblatex-gost/doc/biblatex-gost-examples.pdf

\appendix
\ifthenelse{\value{worktype} > 1}{%
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
  }%
}{
  \addtocontents{toc}{%
      \protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
      \protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
  }%
}

\end{document}
